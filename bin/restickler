#!/usr/bin/env bash
#
# Quinn Comendant <quinn@strangecode.com>
# 2021-12-21 21:35:38
# shellcheck disable=SC1111

set -o pipefail;
set -o errexit;
set -o errtrace;
set -o nounset;
set -o noclobber;

restickler_version='1.0.8';
script_start_time=$(date +%s);

c_violet="\033[35m";
c_bold="\033[1m";
c_off="\033[0m";

# Auxiliary files are located as per XDG Base Directory specifications:
# https://wiki.archlinux.org/title/XDG_Base_Directory#User_directories
config_dir=${XDG_CONFIG_HOME:-$HOME/.config/restickler};
state_dir=${XDG_STATE_HOME:-$HOME/.local/state/restickler};
tmp_dir=/tmp;
log_file="$state_dir/log";

# Set up required directories.
mkdir -p "$config_dir/canary" "$config_dir/exclude" "$state_dir" "$tmp_dir/restickler/restore/$config_dir/canary";
touch "${log_file}";

# Default configuration options.
dl_limit='';
ul_limit='';
exclude_file="$config_dir/exclude/default.txt";
dryrun='';
dryrunexec='';
quiet='';
verbose='';
do_check_idle='';
do_check_battery='';
do_check_hotspot='';
do_check_internet='';
backup_interval_hours=0; # By default, back up every time.
forget_interval_hours=24; # 1 day
prune_interval_hours=240; # 10 days
check_interval_hours=168; # 7 days

#
# Functions
#

function _usage() {
    echo -n "restickler ${restickler_version}

A wrapper for restic (https://restic.net/) that supervises back up, forget, prune, check,
and restore test. Designed for macOS, but works on Linux too.
https://github.com/quinncomendant/restickler
Quinn Comendant <quinn@strangecode.com>

USAGE

    restickler [OPTIONS] SOURCE [SOURCE…]

Back up SOURCE and run maintenance tasks on the configured restic repository.

OPTIONS

    -b HOURS          Min interval between back up operations (currently every ${backup_interval_hours} hours).
    -c HOURS          Min interval between check operations (currently every ${check_interval_hours} hours).
    -d MBPS|%         Limit download speed in Mb/s or as a percentage of available bandwidth.
    -e FILE           File containing back up exclusion rules, used as --exclude-file=FILE.
    -f HOURS          Min interval between forget operations (currently every ${forget_interval_hours} hours).
    -h                Display this help message.
    --install-config  Install example config files (will not overwrite existing files):
                        $config_dir/env
                        $config_dir/exclude/default.txt
    -n                Dry run: print the expected outcome to the screen; don’t actually do anything.
    -p HOURS          Min interval between prune operations (currently every ${prune_interval_hours} hours).
    -q                Do not output comprehensive progress report.
    --self-update     Download the replace restickler with the latest release from GitHub.
    -u MBPS|%         Limit upload speed in Mb/s or as a percentage of available bandwidth.
    -v                Display verbose output (-vv to list uploaded files; -vvv to show debugging output).
    -A                Abort if there has been no user activity since last back up.
    -B                Abort if on battery power.
    -H                Abort if connected to an iOS hotspot.
    -I                Abort if internet is unreliable.
    -V                Print version information.

Restickler runs the following commands to maintain the full lifecycle of a healthy repository:

    1. \`restic backup\` (every ${backup_interval_hours} hours or as specified by -b)
    2. \`restic restore\` (restore test file from \`$config_dir/canary/UTC_DATE_TIME\`)
    3. \`restic forget\` (every ${forget_interval_hours} hours or as specified by -f)
    4. \`restic prune\` (every ${prune_interval_hours} hours or as specified by -p)
    5. \`restic check\` (every ${check_interval_hours} hours or as specified by -c)

GETTING STARTED

    1. Install example config files: \`restickler --install-config\`
    2. Configure environment in \`$config_dir/env\` (see ENVIRONMENT VARIABLES below)
    3. Configure excluded paths in \`$config_dir/exclude/default.txt\`
    4. Initialize the repo: \`source $config_dir/env && restic -r gs:YOUR_BUCKET_NAME:/ init\`
    5. Do back up with \`restickler \$HOME\`

For detailed set-up instructions, see https://github.com/quinncomendant/restickler#set-up

ENVIRONMENT VARIABLES

The following environment variables can be defined in \`$config_dir/env\`, which is
automatically included by restickler if it exists:

    RESTIC_REPOSITORY               The restic repository to back up to and maintain.
    RESTIC_PASSWORD_COMMAND         The shell command that outputs the repository password.
                                    (Or use RESTIC_PASSWORD, but this is less secure.)
    GOOGLE_APPLICATION_CREDENTIALS  Path to the GCP Service Account credentials file.
    GOOGLE_PROJECT_ID               GCP project ID.
    HEALTHCHECKS_URL                Healthchecks.io URL to ping on success or failure (optional).

The GOOGLE_* variables can be replaced by the cloud-provider of your choice;
see https://restic.readthedocs.io/en/latest/030_preparing_a_new_repo.html

LOGS

Activity is logged to \`$state_dir/log\`. Use \`-vv\` to record new and modified files.

EXAMPLES

Back up the entire home directory, except files matched by \`$config_dir/exclude/default.txt\`:

    restickler \$HOME

Back up all Apple Photo libraries, with a custom exclude file:

    restickler -e $config_dir/exclude/photoslibrary.txt \$HOME/Pictures/*.photoslibrary

Force back up, forget, prune, and check to run by setting intervals to 0 (removing
the \`$state_dir/last-*-time*\` files would also reset the interval timer):

    restickler -b 0 -f 0 -p 0 -c 0 \$HOME

A sane configuration for crontab: double verbosity to log files as they upload,
skip back up when idle, on battery, using hotspot, or unreliable internet, with
upload and download limited to 75% of available bandwidth (cron needs % to be escaped):

    */7 * * * * restickler -vvABHI -d 75\% -u 75\% -b 1 \$HOME >/dev/null
" | sed "s!${HOME}!~!g" 1>&2
    exit 1;
}

function _install_config() {
    _prompt "Install example config files (\`$config_dir/env\`, \`$config_dir/exclude/default.txt\`)?" || exit 0;
    if [[ -e "$config_dir/env" ]]; then
        _info "$config_dir/env file already exists; skipping";
    else
        http_code=$(curl -sL -w '%{http_code}' -o "$config_dir/env" "https://raw.githubusercontent.com/quinncomendant/restickler/master/config/env?t=${script_start_time}");
        [[ $http_code == 200 ]] || _error "Failed to install $config_dir/env (HTTP code $http_code)";
        chmod 600 "$config_dir/env";
        _info "Installed: \`$config_dir/env\` from https://github.com/quinncomendant/restickler/blob/master/config/env";
    fi
    if [[ -e "$config_dir/exclude/default.txt" ]]; then
        _info "$config_dir/exclude/default.txt file already exists; skipping";
    else
        http_code=$(curl -sL -w '%{http_code}' -o "$config_dir/exclude/default.txt" "https://raw.githubusercontent.com/quinncomendant/restickler/master/config/exclude/default.txt?t=${script_start_time}");
        [[ $http_code == 200 ]] || _error "Failed to install $config_dir/exclude/default.txt (HTTP code $http_code)";
        _info "Installed: \`$config_dir/exclude/default.txt\` from https://github.com/quinncomendant/restickler/blob/master/config/exclude/default.txt";
    fi
    exit 0;
}

function _self_update() {
    self=$(readlink -f "$0");
    tmpdl="$tmp_dir/restickler-${script_start_time}-$(head -c 100 /dev/urandom | LC_ALL=C tr -dc '0-9A-Za-z')";
    cp -p "$self" "$tmpdl"; # Copy existing script just to retain permissions.
    restickler_url="https://raw.githubusercontent.com/quinncomendant/restickler/master/bin/restickler?t=${script_start_time}";
    http_code=$(curl -sL -w '%{http_code}' -o "$tmpdl" "$restickler_url");
    [[ $http_code == 200 ]] || _error "Failed to install $config_dir/exclude/default.txt (HTTP code $http_code)";
    tmp_version=$(sed -n '/^restickler_version=/s/[^0-9.]//gp' "$tmpdl");
    if [[ ! -s "$tmpdl" || -z $tmp_version ]]; then
        _error "Failed to download new version from ${restickler_url}";
    fi
    if [[ "$restickler_version" == "$tmp_version" ]]; then
        _info "restickler ${restickler_version} is currently the newest version available.";
    else
        # shellcheck disable=SC2015
        if _prompt "Update restickler from ${restickler_version} to ${tmp_version}?"; then
            $dryrunexec mv "$tmpdl" "$self" || _error "Failed to replace $self with $tmpdl";
        fi
    fi
    rm -f "$tmpdl" || true;
    exit 0;
}

function _debug() {
    local IFS='' dt;
    dt=$(date '+%F %T');
    # shellcheck disable=SC2015
    [[ $verbose =~ '-v -v -v' ]] && echo -e "[${dt}] [debug] $*" >> "${log_file}" || true;
}

function _info() {
    local IFS='' dt;
    dt=$(date '+%F %T');
    # shellcheck disable=SC2015
    [[ $verbose =~ '-v' ]] && echo -e "[${dt}] [info] $*" >> "${log_file}" || true;
    echo -e "${c_violet}[${dt}] ${c_bold}$*${c_off}";
}

function _warning() {
    local IFS='' dt;
    dt=$(date '+%F %T');
    echo -e "[${dt}] [warning] $*" | tee -a "${log_file}" 1>&2
}

# USR1 signal is sent by _error to terminate the main script.
trap 'exit 1' USR1;
function _error() {
    local IFS='' dt;
    dt=$(date '+%F %T');
    echo -e "[${dt}] [error] $*" | tee -a "${log_file}" 1>&2
    # Send “fail” signal to HealthChecks.io when run via cron.
    # shellcheck disable=SC2015
    [[ -z $dryrun && $TERM == 'dumb' && -n ${HEALTHCHECKS_URL:-} ]] && curl -fsS -X POST --data-binary "[${dt}] $*" --retry 3 "${HEALTHCHECKS_URL}/fail" >/dev/null || true;
    # Send a user-defined USR1 signal, which is trapped to exit the main process.
    kill -USR1 $$;
}

function _prompt() {
    local yn;
    read -rp "$* [y/N]: " yn;
    case $yn in
        ([yY]|[yY][eE][sS]) true;;
        (*) false;;
    esac
}

function _elapsed() {
    printf '%dd%dh%dm%ds' $((SECONDS/86400)) $((SECONDS%86400/3600)) $((SECONDS%3600/60)) $((SECONDS%60)) | sed -E 's/(^0d(0h(0m)?)?)?//';
}

function _online {
    for i in {1..5}; do
        # Return 0 if http response code is in 100-599 range and total response time is less than 1s.
        curl -m 1 -s -o /dev/null -w '%{http_code} %{time_total}' https://storage.googleapis.com/ 2>/dev/null | awk '{exit !($1 ~ /^[12345][0-9][0-9]$/ && $2 < 1)}' && return 0;
        sleep 1;
    done
    # All 5 attempts to connect failed.
    return "$i";
}

function _network_quality() {
    # Return cached internet speed test results from macOS's `networkQuality` command (only available on macOS 12+).
    local jqfilter=${1:-.};

    if [[ ! -s "$state_dir/network_quality.json" && -x $(command -v networkQuality) && ($do_check_internet || $dl_limit == *% || $ul_limit == *%) ]]; then
        networkQuality -cs >| "$state_dir/network_quality.json" || true;
        [[ -s "$state_dir/network_quality.json" ]] && _debug "$(jq -r '"Network DL speed: \(.dl_throughput) UL speed: \(.ul_throughput) UL responsiveness: \(.ul_responsiveness)"' "$state_dir/network_quality.json")";
    fi

    if [[ ! -s "$state_dir/network_quality.json" ]]; then
        # No network test results available; assume the network is very fast (1073741824 == 1 GiB/s).
        echo 1073741824;
        return 0;
    fi

    if jq -e . "$state_dir/network_quality.json" &>/dev/null; then
        # If valid JSON, return requested value.
        jq -r "$jqfilter" "$state_dir/network_quality.json";
        return 0;
    else
        # Otherwise use 0 for all requested values, which will indicate network tests failed.
        echo '0';
        return 1;
    fi
}

function convert_limit() {
    local limit=$1 metric=$2 arg=$3;
    # Convert UL and DL limits specified as a percentage into Mbps limits.
    if [[ $limit == *% ]]; then
        limit=$(bc <<<"scale=4; $(_network_quality "$metric") * ${limit//%} / 100 / 1024 / 1024");
    fi
    # If UL or DL limit is specified, convert from Mbps to KiB/s and return.
    if [[ -n $limit && $limit != 0 ]]; then
        echo -n "${arg}=$(bc <<<"scale=0; $limit * 1024 / 8")";
    fi
}

function _reliable_internet() {
    # Return true if the network has an RPM < 50, DL < 0.5Mbps, or UL < 0.5Mbps.
    (( $(_network_quality .ul_responsiveness) > 50 && $(_network_quality .dl_throughput) > 524288 && $(_network_quality .ul_throughput) > 524288 ));
}

function _computer_has_been_idle() {
    # Return true if the most recent successful back up began after the computer became idle.
    local last_backup_time_file=$1 idle_seconds idle_begin_time last_backup_time;

    [[ -x $(command -v ioreg) ]] || return 1;
    [[ -s "$last_backup_time_file" ]] || return 1;
    idle_seconds=$(ioreg -c IOHIDSystem | awk '/HIDIdleTime/ {print $NF/1000000000; exit}' || true);
    idle_begin_time=$(bc <<<"scale=0; ($script_start_time - ${idle_seconds:-0}) / 1");
    last_backup_time=$(<"$last_backup_time_file");

    (( last_backup_time > idle_begin_time ));
}

function _on_battery_power() {
    # Return true if on macOS battery power.
    [[ -x $(command -v pmset) ]] && pmset -g batt | grep -q "Now drawing from 'Battery Power'";
    # Return exit status of last command (required because pipefail flag is on).
    return "${PIPESTATUS[${#PIPESTATUS[@]}-1]}";
}

function _connected_to_hotspot() {
    # Return true if connected to an iOS Personal Hotspot (which seems to reliably assign an IP address in the 172.20.10.xxx range).
    [[ -x $(command -v networksetup) ]] && networksetup -listallnetworkservices | grep -v 'An asterisk' | xargs networksetup -getinfo | grep -q 'IP address: 172\.20\.10\.';
    # Return exit status of last command (required because pipefail flag is on).
    return "${PIPESTATUS[${#PIPESTATUS[@]}-1]}";
}

function _repository_is_locked() {
    local command=$1 running_restic;
    if [[ -n "$(restic -q --no-lock list locks)" ]]; then
        # shellcheck disable=SC2009
        running_restic=$(ps -Ao command | grep '^[/a-z]*restic ' || true);
        if [[ -n $running_restic ]]; then
            _warning "Skipping ${command} because repository is locked (possibly by “${running_restic}”)";
        else
            _warning "Skipping ${command} because repository is locked (run \`source $config_dir/env && restic unlock\` after confirming no restic processes are running)";
        fi
        return 0;
    fi
    return 1;
}

function _restic_backup() {
    local last_backup_time_file;
    last_backup_time_file="$state_dir/last-backup-time-$(LC_ALL=C tr -c '0-9A-Za-z\n' - <<<"$*")";

    if [[ -s "$last_backup_time_file" && $(<"$last_backup_time_file") -gt $((script_start_time - (60 * 60 * backup_interval_hours))) ]]; then
        _info "Skipping back up (last ran $(bc <<<"scale=1; ($script_start_time - $(<"$last_backup_time_file")) / 60 / 60") hours ago)";
        return 1;
    fi

    if [[ -n $do_check_idle ]] && _computer_has_been_idle "$last_backup_time_file"; then
        _info "Skipping back up because computer has been idle since last back up";
        return 1;
    fi

    if [[ -n $do_check_battery ]] && _on_battery_power; then
        _info "Skipping back up while on battery";
        return 1;
    fi

    if [[ -n $do_check_hotspot ]] && _connected_to_hotspot; then
        _info "Skipping back up while connected to hotspot";
        return 1;
    fi

    if ! _online; then
        _info "Aborting back up because network is offline";
        exit 0;
    fi

    if [[ -n $do_check_internet ]] && ! _reliable_internet; then
        _info "Aborting back up because of unreliable internet";
        exit 1;
    fi

    # Send “start” signal to HealthChecks.io when run via cron.
    # shellcheck disable=SC2015
    [[ -z $dryrun && $TERM == 'dumb' && -n ${HEALTHCHECKS_URL:-} ]] && curl -fsS -X POST --data-binary "Starting back up of $*" --retry 3 "${HEALTHCHECKS_URL}/start" >/dev/null || true;

    _info "Starting back up";
    local limit_download limit_upload;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    # shellcheck disable=SC2086
    $caffeinate restic $quiet $verbose $limit_download $limit_upload backup "$@" \
        $exclude_file \
        $dryrun \
        2>&1 | { grep -v '^unchanged' || true; } | tee -a "${log_file}" | { grep -Ev '^(modified|new)' || true; } || _error "Failed to back up ($(_elapsed) elapsed)"

    # Save the timestamp of when this script began running to the `last-backup-time-…` file.
    [[ -z $dryrun ]] && echo -n "$script_start_time" >| "$last_backup_time_file";

    # Send “success” signal to HealthChecks.io when run via cron.
    # shellcheck disable=SC2015
    [[ -z $dryrun && $TERM == 'dumb' && -n ${HEALTHCHECKS_URL:-} ]] && curl -fsS -X POST --data-binary "Finished back up ($(_elapsed) elapsed)" --retry 3 "${HEALTHCHECKS_URL}" >/dev/null || true;
}

function _restic_test_restore() {
    # shellcheck disable=SC2076
    if [[ ! $(printf ':%s:' "$@") =~ ":$HOME:" ]]; then
        _info "Skipping test restore because $HOME does not match any source argument";
        return 1;
    fi

    _info "Starting test restore";
    local limit_download limit_upload latest_snapshot;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    latest_snapshot=$(restic snapshots --json --path "$HOME" latest | jq -r '.[0].short_id');
    # shellcheck disable=SC2086
    $dryrunexec $caffeinate restic $quiet $verbose $limit_download $limit_upload restore "$latest_snapshot" \
        --target "$tmp_dir/restickler/restore" \
        --include "$config_dir/canary" \
        2>&1 | tee -a "${log_file}" | { grep -v '^restoring' || true; } || _error "Failed to restore ($(_elapsed) elapsed)"

    [[ -n $dryrun ]] || diff "${canary_file}" "$tmp_dir/restickler/restore/${canary_file}" >/dev/null || _error "Restored canary doesn’t match backed-up version ($(_elapsed) elapsed)"
}

function _restic_forget() {
    if [[ -s "$state_dir/last-forget-time" && $(<"$state_dir/last-forget-time") -gt $((script_start_time - (60 * 60 * forget_interval_hours))) ]]; then
        _info "Skipping forget (last ran $(bc <<<"scale=1; ($script_start_time - $(<"$state_dir/last-forget-time")) / 60 / 60") hours ago)";
        return 1;
    fi

    if ! _online; then
        _info "Aborting forget because network is offline";
        exit 0;
    fi

    if [[ -n $do_check_internet ]] && ! _reliable_internet; then
        _info "Aborting forget because of unreliable internet";
        exit 1;
    fi

    _repository_is_locked forget && return 1;

    _info "Starting forget";
    local limit_download limit_upload;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    # shellcheck disable=SC2086
    $caffeinate restic $quiet $verbose $limit_download $limit_upload forget \
        --keep-last 72 \
        --keep-within-hourly 14d \
        --keep-within-daily 45d \
        --keep-within-weekly 3m \
        --keep-within-monthly 1y \
        --keep-within-yearly 10y \
        $dryrun \
        2>&1 | tee -a "${log_file}" || _error "Failed to forget ($(_elapsed) elapsed)"

    # Save the timestamp of successful forget.
    [[ -z $dryrun ]] && echo -n "$script_start_time" >| "$state_dir/last-forget-time";
}

function _restic_prune() {
    if [[ -s "$state_dir/last-prune-time" && $(<"$state_dir/last-prune-time") -gt $((script_start_time - (60 * 60 * prune_interval_hours))) ]]; then
        _info "Skipping prune (last ran $(bc <<<"scale=1; ($script_start_time - $(<"$state_dir/last-prune-time")) / 60 / 60") hours ago)";
        return 1;
    fi

    if [[ -n $do_check_battery ]] && _on_battery_power; then
        _info "Skipping prune while on battery";
        return 1;
    fi

    if [[ -n $do_check_hotspot ]] && _connected_to_hotspot; then
        _info "Skipping prune while connected to hotspot";
        return 1;
    fi

    if ! _online; then
        _info "Aborting prune because network is offline";
        exit 0;
    fi

    if [[ -n $do_check_internet ]] && ! _reliable_internet; then
        _info "Aborting prune because of unreliable internet";
        exit 1;
    fi

    _repository_is_locked prune && return 1;

    _info "Starting prune";
    local limit_download limit_upload;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    # shellcheck disable=SC2086
    $caffeinate restic $quiet $verbose $limit_download $limit_upload prune \
        $dryrun \
        2>&1 | tee -a "${log_file}" || _error "Failed to prune ($(_elapsed) elapsed)"

    # Save the timestamp of successful prune.
    [[ -z $dryrun ]] && echo -n "$script_start_time" >| "$state_dir/last-prune-time";
}

function _restic_check() {
    if [[ -s "$state_dir/last-check-time" && $(<"$state_dir/last-check-time") -gt $((script_start_time - (60 * 60 * check_interval_hours))) ]]; then
        _info "Skipping check (last ran $(bc <<<"scale=1; ($script_start_time - $(<"$state_dir/last-check-time")) / 60 / 60") hours ago)";
        return 1;
    fi

    if [[ -n $do_check_battery ]] && _on_battery_power; then
        _info "Skipping check while on battery";
        return 1;
    fi

    if [[ -n $do_check_hotspot ]] && _connected_to_hotspot; then
        _info "Skipping check while connected to hotspot";
        return 1;
    fi

    if ! _online; then
        _info "Aborting check because network is offline";
        exit 0;
    fi

    if [[ -n $do_check_internet ]] && ! _reliable_internet; then
        _info "Aborting check because of unreliable internet";
        exit 1;
    fi

    _repository_is_locked check && return 1;

    _info "Starting check";
    # Check might be redundant with `prune`, except for the doubt in this comment: https://forum.restic.net/t/should-i-run-restic-check/1227/9?u=quinncom
    # Verify 1/52th of the total repo data every week.
    local limit_download limit_upload;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    # shellcheck disable=SC2086
    $dryrunexec $caffeinate restic $quiet $verbose $limit_download $limit_upload check \
        --read-data-subset="$(date +%V)/52" \
        2>&1 | tee -a "${log_file}" || _error "Failed to check ($(_elapsed) elapsed)"

    # Save the timestamp of successful check.
    [[ -z $dryrun ]] && echo -n "$script_start_time" >| "$state_dir/last-check-time";
}


#
# Get ready
#

# Display help if run without arguments.
[[ $# == 0 ]] && _usage;

# Process command line options.
while getopts "b:c:d:e:f:hnp:qu:vABHIV-:" opt ; do
    case $opt in
        (b) backup_interval_hours=${OPTARG%.*};; # Args with hours need to be integers.
        (c) check_interval_hours=${OPTARG%.*};;
        (d) dl_limit=$OPTARG;;
        (e) exclude_file=$OPTARG;;
        (f) forget_interval_hours=${OPTARG%.*};;
        (h) _usage;;
        (n) dryrun='--dry-run'; dryrunexec='echo DRY-RUN:';;
        (p) prune_interval_hours=${OPTARG%.*};;
        (q) quiet="--quiet";;
        (u) ul_limit=$OPTARG;;
        (v) verbose="-v ${verbose}";;
        (A) do_check_idle=1;;
        (B) do_check_battery=1;;
        (H) do_check_hotspot=1;;
        (I) do_check_internet=1;;
        (V) echo -n "restickler ${restickler_version} ($([[ -x $(command -v restic) ]] && restic version))"; exit 0;;
        (-) case $OPTARG in
            (self-update) _self_update;;
            (install-config) _install_config;;
            (help) _usage;;
            (?) _error "Invalid option: \`$OPTARG\`. Use option -h for help.";;
        esac ;;
        (?) _error "Invalid option: \`$opt\`. Use option -h for help.";;
        (*) _error "An unexpected error occurred.";;
    esac
done
[[ -n $exclude_file ]] && exclude_file="--exclude-file=${exclude_file}";
shift $((OPTIND - 1));

# Additional arguments are backup sources. Verify them.
for src in "$@"; do
    [[ $src =~ ^/ ]] || _error "Source directory “${src}” must be an absolute path";
    [[ -z $src || ! -d "$src" ]] && _error "Source directory “${src}” doesn’t exist";
done

# Test dependencies.
[[ -x $(command -v restic) ]] || _error "The restic command is not available";
[[ -x $(command -v curl) ]] || _error "The curl command is not available";
[[ -x $(command -v jq) ]] || _error "The jq command is not available";
[[ -x $(command -v bc) ]] || _error "The bc command is not available";
[[ -x $(command -v tr) ]] || _error "The tr command is not available";
[[ -x $(command -v awk) ]] || _error "The awk command is not available";
[[ -x $(command -v readlink) ]] || _error "The readlink command is not available";
[[ -x $(command -v curl) ]] || _error "The curl command is not available";

restic_min_version='0.13.0';
restic_installed_version=$(restic version | awk '{print $2}');
if [[ "$restic_min_version" != "$(echo -e "${restic_installed_version}\n${restic_min_version}" | sort -V | head -1)" ]]; then
    _error "This script requires restic >= $restic_min_version (installed version is $restic_installed_version). Upgrade with: \`$(readlink -f "$(which restic)") self-update\`.";
fi

# Enforce single-instance execution (via mkdir, which creates atomic lock and check at once).
mkdir "$tmp_dir/restickler/lock" 2>/dev/null || ( _info "Another restickler process is awaiting completion."; exit 1; );

# networkQuality results are regenerated each time restickler runs.
rm -f "$state_dir/network_quality.json";

_trap() {
    local status=$? sig=$1 line=$2;
    case $sig in
        (HUP) _info "Received SIGHUP; continuing anyways…";;
        (INT|TERM) _error "Restickler terminated via ${sig} ($(_elapsed) elapsed)";;
        (ERR) _error "Exit status ${status} on line ${line}: \`${BASH_COMMAND}\` ($(_elapsed) elapsed)";;
        # Trap EXIT must occur after the lock test, otherwise the exit would remove the lock used by the other process.
        (EXIT) rm -fr "$tmp_dir/restickler/lock";;
        (*) _error "Unhandled signal ${sig} with status ${status} on line ${line}";;
    esac
}
trap '_trap HUP $LINENO' HUP;
trap '_trap INT $LINENO' INT;
trap '_trap TERM $LINENO' TERM;
trap '_trap ERR $LINENO' ERR;
trap '_trap EXIT $LINENO' EXIT;

# caffeinate is only available on macOS.
caffeinate='';
[[ -x $(command -v caffeinate) ]] && caffeinate='caffeinate -i';

# Load environment variables used by restic and restickler.
# shellcheck disable=SC1091
[[ -f "$config_dir/env" ]] && source "$config_dir/env";
if [[ -z $RESTIC_REPOSITORY || ( -z $RESTIC_PASSWORD_COMMAND && -z $RESTIC_PASSWORD ) ]]; then
    _error "Missing restic environment variable(s): RESTIC_REPOSITORY and/or RESTIC_PASSWORD_COMMAND; see https://restic.readthedocs.io/en/latest/040_backup.html#environment-variables";
fi

if ! _online; then
    _info "Aborting because network is offline";
    exit 0;
fi

# Make sure the remote repository exists.
restic snapshots >/dev/null || _error "Failed to connect to repository ${RESTIC_REPOSITORY}";

# Generate a “canary” file to test restore later. A 10KB file * 24 * 365 * 10 ≈ 855 MB per decade.
# Only when the home directory is in the set of sources, because we need $config_dir/canary in the backup.
canary_file="$config_dir/canary/$(TZ=UTC date '+%FT%H%M%SZ')";
# shellcheck disable=SC2076
if [[ $(printf ':%s:' "$@") =~ ":$HOME:" ]]; then
    find "$config_dir/canary" "$tmp_dir/restickler/restore/$config_dir/canary" -type f -delete;
    head -c 10240 /dev/urandom > "$canary_file"
fi

#
# Go!
#

_info "Starting restickler $* to ${RESTIC_REPOSITORY}";

# shellcheck disable=SC2015
_restic_backup "$@" && _restic_test_restore "$@" || true;
_restic_forget || true;
_restic_prune || true;
_restic_check || true;

_info "Finished ($(_elapsed) elapsed)";
