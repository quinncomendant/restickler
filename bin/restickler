#!/usr/bin/env bash
#
# Quinn Comendant <quinn@strangecode.com>
# 2021-12-21 21:35:38
# shellcheck disable=SC1111

set -o pipefail;
set -o errexit;
set -o errtrace;
set -o nounset;
set -o noclobber;

restickler_version='1.0.1';
script_start_time=$(date +%s);
log_file="$HOME/var/restickler/log";

c_violet="\033[35m";
c_bold="\033[1m";
c_off="\033[0m";

# Default configuration options.
dl_limit='';
ul_limit='';
exclude_file="$HOME/etc/restickler/exclude/restickler.txt";
dryrun='';
dryrunexec='';
quiet='';
verbose='';
do_check_idle='';
do_check_battery='';
do_check_hotspot='';
do_check_internet='';
backup_interval_hours=0; # By default, back up every time.
forget_interval_hours=24; # 1 day
prune_interval_hours=240; # 10 days
check_interval_hours=168; # 7 days

#
# Functions
#

function _usage() {
    echo -n "restickler ${restickler_version}

Supervise restic to back up, test restore, forget, prune, and check.
https://github.com/quinncomendant/restickler
Quinn Comendant <quinn@strangecode.com>

USAGE

  restickler [OPTIONS] SOURCE [SOURCE…]

Back up SOURCE to the restic repository configured in \`~/etc/restickler/env\`.

OPTIONS

  -b HOURS       Min interval between back up operations (currently every ${backup_interval_hours} hours).
  -c HOURS       Min interval between check operations (currently every ${check_interval_hours} hours).
  -d MBPS|%      Limit download speed in Mb/s or as a percentage of available bandwidth, e.g., \`-d 50%\`.
  -e FILE        File containing back up exclusion rules, used as --exclude-file=FILE.
  -f HOURS       Min interval between forget operations (currently every ${forget_interval_hours} hours).
  -h             Display this help message.
  -n             Dry run: print the expected outcome to the screen; don’t actually do anything.
  -p HOURS       Min interval between prune operations (currently every ${prune_interval_hours} hours).
  -q             Do not output comprehensive progress report.
  -u MBPS|%      Limit upload speed in Mb/s or as a percentage of available bandwidth, e.g., \`-u 50%\`.
  -v             Display verbose output (-vv or -vvv to list uploaded files).
  -A             Abort if there has been no user activity since last back up.
  -B             Abort if on battery power.
  -H             Abort if connected to an iOS hotspot.
  -I             Abort if internet is unreliable.
  -V             Print version information.
  --self-update  Download the replace restickler with the latest release from GitHub.

restickler runs the following commands to maintain the full lifecycle of a healthy repository:

  1. \`restic backup\` (every ${backup_interval_hours} hours or as specified by -b)
  2. \`restic restore\` (test of a single “canary” file at \`~/etc/restickler/canary/{DATETIME}\`)
  3. \`restic forget\` (every ${check_interval_hours} hours or as specified by -f)
  4. \`restic prune\` (every ${forget_interval_hours} hours or as specified by -p)
  5. \`restic check\` (every ${prune_interval_hours} hours or as specified by -c)

GETTING STARTED

  1. Configure credentials and repository in \`~/etc/restickler/env\` (see ENVIRONMENT VARIABLES below)
  2. Configure excluded paths in \`~/etc/restickler/exclude/restickler.txt\`
  3. Initialize the backup destination: \`restic -r gs://backup-bucket-name:/ init\`
  4. Do back up with \`restickler \$HOME\`

About every year-or-so, when connected to fast internet, run \`restic check --read-data\` to verify all data.

ENVIRONMENT VARIABLES

The following environment variables must be defined in \`~/etc/restickler/env\`:

  RESTIC_PASSWORD_COMMAND         The shell command to obtain the repository password from.
  GOOGLE_PROJECT_ID               GCP project ID.
  GOOGLE_APPLICATION_CREDENTIALS  GCP Service Account credentials.
  RESTIC_REPOSITORY               The repository to back up to and restore from.
  HEALTHCHECKS_URL                The URL to ping for back up success or failure at Healthchecks.io (optional).

The GOOGLE_* variables can be replaced by the cloud-provider of your choice;
see https://restic.readthedocs.io/en/latest/030_preparing_a_new_repo.html

EXAMPLES

Back up the home directory:

  restickler \$HOME

Back up home, print files as they upload, limited to 50% of the available bandwidth:

  restickler -vv -d 50% -u 50% \$HOME

Force forget, prune, and check to run by setting intervals to 0 (removing the
~/var/restickler/last-*-time files would also reset the interval timer):

  restickler -f 0 -p 0 -c 0 \$HOME

A sane configuration for crontab (cron needs % to be escaped):

  0 * * * * restickler -vvABHI -d 75\% -u 75\% -b 1 -f 24 -p 168 -c 72 \$HOME >/dev/null

Back up multiple paths, with a custom excludes file:

  restickler -e \$HOME/etc/restickler/exclude/library.txt \$HOME/Library/Application\ Support/{MailMate,TextMate}

To pause restickler (do this before editing this script in production):

    mkdir /tmp/restickler/lock

To unpause restickler (or restart computer, which clears /tmp/ files):

    rm -r /tmp/restickler/lock
" 1>&2
    exit 1;
}

function _self_update() {
    self=$(readlink -f "$0");
    tmpdl="/tmp/restickler-${script_start_time}-$(head -c 100 /dev/urandom | LC_ALL=C tr -dc '0-9A-Za-z')";
    cp -p "$self" "$tmpdl"; # Copy existing script just to retain permissions.
    restickler_url="https://raw.githubusercontent.com/quinncomendant/restickler/master/bin/restickler?t=${script_start_time}";
    curl -sLo "$tmpdl" "$restickler_url";
    tmp_version=$(sed -n '/^restickler_version=/s/[^0-9.]//gp' "$tmpdl");
    if [[ ! -s "$tmpdl" || -z $tmp_version ]]; then
        _error "Failed to download new version from ${restickler_url}";
    fi
    if [[ "$restickler_version" == "$tmp_version" ]]; then
        _info "restickler ${restickler_version} is currently the newest version available.";
    else
        _info "Updating restickler from ${restickler_version} to ${tmp_version}…";
        $dryrunexec mv "$tmpdl" "$self" || _error "Failed to replace $self with $tmpdl";
    fi
    exit 0;
}

function _debug() {
    local IFS='' dt;
    dt=$(date '+%F %T');
    echo -e "[${dt}] [debug] $*" >> "${log_file}";
}

function _info() {
    local IFS='' dt;
    dt=$(date '+%F %T');
    echo -e "[${dt}] [info] $*" >> "${log_file}";
    echo -e "${c_violet}[${dt}] ${c_bold}$*${c_off}";
}

function _warning() {
    local IFS='' dt;
    dt=$(date '+%F %T');
    echo -e "[${dt}] [warning] $*" | tee -a "${log_file}" 1>&2
}

# USR1 signal is sent by _error to terminate the main script.
trap 'exit 1' USR1;

function _error() {
    local IFS='' dt;
    dt=$(date '+%F %T');
    echo -e "[${dt}] [error] $*" | tee -a "${log_file}" 1>&2
    # Send “fail” signal to HealthChecks.io when run via cron.
    # shellcheck disable=SC2015
    [[ -z $dryrun && $TERM == 'dumb' && -n ${HEALTHCHECKS_URL:-} ]] && curl -fsS -X POST --data-binary "[${dt}] $*" --retry 3 "${HEALTHCHECKS_URL}/fail" >/dev/null || true;
    # Send a user-defined USR1 signal, which is trapped to exit the main process.
    kill -USR1 $$;
}

function _elapsed() {
    printf '%dd%dh%dm%ds' $((SECONDS/86400)) $((SECONDS%86400/3600)) $((SECONDS%3600/60)) $((SECONDS%60)) | sed -E 's/(^0d(0h(0m)?)?)?//';
}

# Return 0 on the first successful ping, or return 1 if no ping after 9 seconds.
function _online {
    # shellcheck disable=SC2034
    for i in {1..10}; do
        if (ping -t 1 -i .1 storage.googleapis.com) &>/dev/null; then
            return 0;
        fi
    done
    return 1;
}

function _network_quality() {
    # Return cached internet speed test results from macOS's `networkQuality` command (only available on macOS 12+).
    local jqfilter=${1:-.};

    if [[ ! -s "$HOME/var/restickler/network_quality.json" && -x $(command -v networkQuality) && ($do_check_internet || $dl_limit == *% || $ul_limit == *%) ]]; then
        networkQuality -cs >| "$HOME/var/restickler/network_quality.json" || true;
        [[ -n $verbose && -s "$HOME/var/restickler/network_quality.json" ]] && _debug "$(jq -r '"Network DL speed: \(.dl_throughput) UL speed: \(.ul_throughput) UL responsiveness: \(.ul_responsiveness)"' "$HOME/var/restickler/network_quality.json")";
    fi

    if [[ ! -s "$HOME/var/restickler/network_quality.json" ]]; then
        # No network test results available; assume the network is very fast (1073741824 == 1 GiB/s).
        echo 1073741824;
        return 0;
    fi

    if jq -e . "$HOME/var/restickler/network_quality.json" &>/dev/null; then
        # If valid JSON, return requested value.
        jq -r "$jqfilter" "$HOME/var/restickler/network_quality.json";
        return 0;
    else
        # Otherwise use 0 for all requested values, which will indicate network tests failed.
        echo '0';
        return 1;
    fi
}

function convert_limit() {
    local limit=$1 metric=$2 arg=$3;
    # Convert UL and DL limits specified as a percentage into Mbps limits.
    if [[ $limit == *% ]]; then
        limit=$(bc <<<"scale=4; $(_network_quality "$metric") * ${limit//%} / 100 / 1024 / 1024"); # Mbps
    fi
    # If UL or DL limit is specified, convert from Mbps to KiB/s and return.
    if [[ -n $limit && $limit != 0 ]]; then
        echo -n "${arg}=$(bc <<<"scale=0; $limit * 1024 / 8")"; # KiB/s
    fi
}

function _unreliable_internet() {
    # Return true if the network has an RPM < 50, DL < 0.5Mbps, or UL < 0.5Mbps.
    (( $(_network_quality .ul_responsiveness) < 50 || $(_network_quality .dl_throughput) < 524288 || $(_network_quality .ul_throughput) < 524288 ));
}

function _computer_has_been_idle() {
    # Return true if the most recent successful back up began after the computer became idle.
    local last_backup_time_file=$1 idle_seconds idle_begin_time last_backup_time;

    [[ -x $(command -v ioreg) ]] || return 1;
    [[ -s "$last_backup_time_file" ]] || return 1;
    idle_seconds=$(ioreg -c IOHIDSystem | awk '/HIDIdleTime/ {print $NF/1000000000; exit}' || true);
    idle_begin_time=$(bc <<<"scale=0; ($script_start_time - ${idle_seconds:-0}) / 1");
    last_backup_time=$(<"$last_backup_time_file");

    (( last_backup_time > idle_begin_time ));
}

function _on_battery_power() {
    # Return true if on macOS battery power.
    [[ -x $(command -v pmset) ]] && pmset -g batt | grep -q "Now drawing from 'Battery Power'";
    # Return exit status of last command (required because pipefail flag is on).
    return "${PIPESTATUS[${#PIPESTATUS[@]}-1]}";
}

function _connected_to_hotspot() {
    # Return true if connected to an iOS Personal Hotspot (which seems to reliably assign an IP address in the 172.20.10.xxx range).
    [[ -x $(command -v networksetup) ]] && networksetup -listallnetworkservices | grep -v 'An asterisk' | xargs networksetup -getinfo | grep -q 'IP address: 172\.20\.10\.';
    # Return exit status of last command (required because pipefail flag is on).
    return "${PIPESTATUS[${#PIPESTATUS[@]}-1]}";
}

function _repository_is_locked() {
    local command=$1 running_restic;
    if [[ -n "$(restic -q --no-lock list locks)" ]]; then
        # shellcheck disable=SC2009
        running_restic=$(ps -Ao command | grep '^[/a-z]*restic ');
        if [[ -n $running_restic ]]; then
            _warning "Skipping ${command} because repository is locked (possibly by “${running_restic}”)";
        else
            _warning "Skipping ${command} because repository is locked (run \`restic unlock\` after confirming no restic processes are running)";
        fi
        return 0;
    fi
    return 1;
}

function _restic_backup() {
    local last_backup_time_file;
    last_backup_time_file="$HOME/var/restickler/last-backup-time-$(md5 <<<"$*")";

    if [[ -s "$last_backup_time_file" && $(<"$last_backup_time_file") -gt $((script_start_time - (60 * 60 * backup_interval_hours))) ]]; then
        _info "Skipping back up (last ran $(bc <<<"scale=1; ($script_start_time - $(<"$last_backup_time_file")) / 60 / 60") hours ago)";
        return 1;
    fi

    if [[ -n $do_check_idle ]] && _computer_has_been_idle "$last_backup_time_file"; then
        _info "Skipping back up because computer has been idle since last back up";
        return 1;
    fi

    if [[ -n $do_check_battery ]] && _on_battery_power; then
        _info "Skipping back up while on battery";
        return 1;
    fi

    if [[ -n $do_check_hotspot ]] && _connected_to_hotspot; then
        _info "Skipping back up while connected to hotspot";
        return 1;
    fi

    if ! _online; then
        _info "Aborting back up because network is offline";
        exit 0;
    fi

    if [[ -n $do_check_internet ]] && _unreliable_internet; then
        _info "Aborting back up because of unreliable internet";
        exit 1;
    fi

    # Send “start” signal to HealthChecks.io when run via cron.
    # shellcheck disable=SC2015
    [[ -z $dryrun && $TERM == 'dumb' && -n ${HEALTHCHECKS_URL:-} ]] && curl -fsS -X POST --data-binary "Starting back up of $*" --retry 3 "${HEALTHCHECKS_URL}/start" >/dev/null || true;

    _info "Starting back up";
    local limit_download limit_upload;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    # shellcheck disable=SC2086
    $caffeinate restic $quiet $verbose $limit_download $limit_upload backup "$@" \
        $exclude_file \
        $dryrun \
        2>&1 | { grep -v '^unchanged' || true; } | tee -a "${log_file}" | { grep -Ev '^(modified|new)' || true; } || _error "Failed to back up ($(_elapsed) elapsed)"

    # Save the timestamp of when this script began running to the `last-backup-time-md5…` file.
    [[ -z $dryrun ]] && echo -n "$script_start_time" >| "$last_backup_time_file";

    # Send “success” signal to HealthChecks.io when run via cron.
    # shellcheck disable=SC2015
    [[ -z $dryrun && $TERM == 'dumb' && -n ${HEALTHCHECKS_URL:-} ]] && curl -fsS -X POST --data-binary "Finished back up ($(_elapsed) elapsed)" --retry 3 "${HEALTHCHECKS_URL}" >/dev/null || true;
}

function _restic_test_restore() {
    if [[ $HOME != "$*" ]]; then
        _info "Skipping test restore because $HOME != $*";
        return 1;
    fi

    _info "Starting test restore";
    local limit_download limit_upload latest_snapshot;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    latest_snapshot=$(restic snapshots --json --path "$HOME" latest | jq -r '.[0].short_id');
    # shellcheck disable=SC2086
    $dryrunexec $caffeinate restic $quiet $verbose $limit_download $limit_upload restore "$latest_snapshot" \
        --target "/tmp/restickler/restore" \
        --include "$HOME/etc/restickler/canary" \
        2>&1 | tee -a "${log_file}" | { grep -v '^restoring' || true; } || _error "Failed to restore ($(_elapsed) elapsed)"

    [[ -n $dryrun ]] || diff "${canary_file}" "/tmp/restickler/restore/${canary_file}" >/dev/null || _error "Restored canary doesn’t match backed-up version ($(_elapsed) elapsed)"
}

function _restic_forget() {
    if [[ -s "$HOME/var/restickler/last-forget-time" && $(<"$HOME/var/restickler/last-forget-time") -gt $((script_start_time - (60 * 60 * forget_interval_hours))) ]]; then
        _info "Skipping forget (last ran $(bc <<<"scale=1; ($script_start_time - $(<"$HOME/var/restickler/last-forget-time")) / 60 / 60") hours ago)";
        return 1;
    fi

    if ! _online; then
        _info "Aborting forget because network is offline";
        exit 0;
    fi

    if [[ -n $do_check_internet ]] && _unreliable_internet; then
        _info "Aborting forget because of unreliable internet";
        exit 1;
    fi

    _repository_is_locked forget && return 1;

    _info "Starting forget";
    local limit_download limit_upload;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    # shellcheck disable=SC2086
    $caffeinate restic $quiet $verbose $limit_download $limit_upload forget \
        --keep-last 72 \
        --keep-within-hourly 14d \
        --keep-within-daily 45d \
        --keep-within-weekly 3m \
        --keep-within-monthly 1y \
        --keep-within-yearly 10y \
        $dryrun \
        2>&1 | tee -a "${log_file}" || _error "Failed to forget ($(_elapsed) elapsed)"

    # Save the timestamp of successful forget.
    [[ -z $dryrun ]] && echo -n "$script_start_time" >| "$HOME/var/restickler/last-forget-time";
}

function _restic_prune() {
    if [[ -s "$HOME/var/restickler/last-prune-time" && $(<"$HOME/var/restickler/last-prune-time") -gt $((script_start_time - (60 * 60 * prune_interval_hours))) ]]; then
        _info "Skipping prune (last ran $(bc <<<"scale=1; ($script_start_time - $(<"$HOME/var/restickler/last-prune-time")) / 60 / 60") hours ago)";
        return 1;
    fi

    if [[ -n $do_check_battery ]] && _on_battery_power; then
        _info "Skipping prune while on battery";
        return 1;
    fi

    if [[ -n $do_check_hotspot ]] && _connected_to_hotspot; then
        _info "Skipping prune while connected to hotspot";
        return 1;
    fi

    if ! _online; then
        _info "Aborting prune because network is offline";
        exit 0;
    fi

    if [[ -n $do_check_internet ]] && _unreliable_internet; then
        _info "Aborting prune because of unreliable internet";
        exit 1;
    fi

    _repository_is_locked prune && return 1;

    _info "Starting prune";
    local limit_download limit_upload;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    # shellcheck disable=SC2086
    $caffeinate restic $quiet $verbose $limit_download $limit_upload prune \
        $dryrun \
        2>&1 | tee -a "${log_file}" || _error "Failed to prune ($(_elapsed) elapsed)"

    # Save the timestamp of successful prune.
    [[ -z $dryrun ]] && echo -n "$script_start_time" >| "$HOME/var/restickler/last-prune-time";
}

function _restic_check() {
    if [[ -s "$HOME/var/restickler/last-check-time" && $(<"$HOME/var/restickler/last-check-time") -gt $((script_start_time - (60 * 60 * check_interval_hours))) ]]; then
        _info "Skipping check (last ran $(bc <<<"scale=1; ($script_start_time - $(<"$HOME/var/restickler/last-check-time")) / 60 / 60") hours ago)";
        return 1;
    fi

    if [[ -n $do_check_battery ]] && _on_battery_power; then
        _info "Skipping check while on battery";
        return 1;
    fi

    if [[ -n $do_check_hotspot ]] && _connected_to_hotspot; then
        _info "Skipping check while connected to hotspot";
        return 1;
    fi

    if ! _online; then
        _info "Aborting check because network is offline";
        exit 0;
    fi

    if [[ -n $do_check_internet ]] && _unreliable_internet; then
        _info "Aborting check because of unreliable internet";
        exit 1;
    fi

    _repository_is_locked check && return 1;

    _info "Starting check";
    # Check might be redundant with `prune`, except for the doubt in this comment: https://forum.restic.net/t/should-i-run-restic-check/1227/9?u=quinncom
    # Verify 1/52th of the total repo data every week.
    local limit_download limit_upload;
    limit_download=$(convert_limit "$dl_limit" ".dl_throughput" "--limit-download");
    limit_upload=$(convert_limit "$ul_limit" ".ul_throughput" "--limit-upload");
    # shellcheck disable=SC2086
    $dryrunexec $caffeinate restic $quiet $verbose $limit_download $limit_upload check \
        --read-data-subset="$(date +%V)/52" \
        2>&1 | tee -a "${log_file}" || _error "Failed to check ($(_elapsed) elapsed)"

    # Save the timestamp of successful check.
    [[ -z $dryrun ]] && echo -n "$script_start_time" >| "$HOME/var/restickler/last-check-time";
}


#
# Get ready
#

# Display help if run without arguments.
[[ $# == 0 ]] && _usage;

# Process command line options.
while getopts "b:c:d:e:f:hnp:qu:vABHIV-:" opt ; do
    case $opt in
        (b) backup_interval_hours=${OPTARG%.*};; # Args with hours need to be integers.
        (c) check_interval_hours=${OPTARG%.*};;
        (d) dl_limit=$OPTARG;;
        (e) exclude_file=$OPTARG;;
        (f) forget_interval_hours=${OPTARG%.*};;
        (h) _usage;;
        (n) dryrun='--dry-run'; dryrunexec='echo DRY-RUN:';;
        (p) prune_interval_hours=${OPTARG%.*};;
        (q) quiet="--quiet";;
        (u) ul_limit=$OPTARG;;
        (v) verbose="-v ${verbose}";;
        (A) do_check_idle=1;;
        (B) do_check_battery=1;;
        (H) do_check_hotspot=1;;
        (I) do_check_internet=1;;
        (V) echo -n "restickler ${restickler_version} ($([[ -x $(command -v restic) ]] && restic version))"; exit 0;;
        (-) case $OPTARG in
            (self-update) _self_update;;
            (help) _usage;;
            (?) _error "Invalid option: '$OPTARG'. Run with no arguments for help.";;
        esac ;;
        (?) _error "Invalid option: '$opt'. Run with no arguments for help.";;
        (*) _error "An unexpected error occurred.";;
    esac
done
[[ -n $exclude_file ]] && exclude_file="--exclude-file=${exclude_file}";
shift $((OPTIND - 1));

# Additional arguments are backup sources. Verify them.
for src in "$@"; do
    [[ $src =~ ^/ ]] || _error "Source directory “${src}” must be an absolute path";
    [[ -z $src || ! -d "$src" ]] && _error "Source directory “${src}” doesn’t exist";
done

# Test dependencies.
[[ -x $(command -v restic) ]] || _error "The restic command is not available";
[[ -x $(command -v curl) ]] || _error "The curl command is not available";
[[ -x $(command -v jq) ]] || _error "The jq command is not available";
[[ -x $(command -v bc) ]] || _error "The bc command is not available";

restic_min_version='0.13.0';
restic_installed_version=$(restic version | awk '{print $2}');
if [[ "$restic_min_version" != "$(echo -e "${restic_installed_version}\n${restic_min_version}" | sort -V | head -1)" ]]; then
    _error "This script requires restic >= $restic_min_version (installed version is $restic_installed_version). Upgrade with: \`$(readlink -f "$(which restic)") self-update\`.";
fi

# Set up required directories.
mkdir -p "$HOME/etc/restickler/canary" "$HOME/var/restickler" "/tmp/restickler/restore/$HOME/etc/restickler/canary";

# Enforce single-instance execution (via mkdir, which creates atomic lock and check at once).
mkdir /tmp/restickler/lock 2>/dev/null || ( _info "Another restickler process is awaiting completion. Please wait and try again later. Run with no arguments for help."; exit 1; );

# networkQuality results are regenerated each time restickler runs.
rm -f "$HOME/var/restickler/network_quality.json";

_trap() {
    local status=$? sig=$1 line=$2;
    case $sig in
        (HUP) _info "Received SIGHUP; continuing anyways…";;
        (INT|TERM) _error "Restickler terminated via ${sig} ($(_elapsed) elapsed)";;
        (ERR) _error "Exit status ${status} on line ${line}: \`${BASH_COMMAND}\` ($(_elapsed) elapsed)";;
        # Trap EXIT must occur after the lock test, otherwise the exit would remove the lock used by the other process.
        (EXIT) rm -fr /tmp/restickler/lock;;
        (*) _error "Unhandled signal ${sig} with status ${status} on line ${line}";;
    esac
}
trap '_trap HUP $LINENO' HUP;
trap '_trap INT $LINENO' INT;
trap '_trap TERM $LINENO' TERM;
trap '_trap ERR $LINENO' ERR;
trap '_trap EXIT $LINENO' EXIT;

# caffeinate is only available on macOS.
caffeinate='';
[[ -x $(command -v caffeinate) ]] && caffeinate='caffeinate -i';

# Load environment variables used to lessen the arguments needed to run restic.
[[ -f "$HOME/etc/restickler/env" ]] || _error "Missing $HOME/etc/restickler/env file";
source "$HOME/etc/restickler/env";
if [[ -z $GOOGLE_PROJECT_ID || -z $GOOGLE_APPLICATION_CREDENTIALS || -z $RESTIC_PASSWORD_COMMAND || -z $RESTIC_REPOSITORY ]]; then
    _error "Missing restic environment variable(s)";
fi

if ! _online; then
    _info "Aborting because network is offline";
    exit 0;
fi

# Make sure the remote repository exists.
restic snapshots >/dev/null || _error "Failed to connect to repository ${RESTIC_REPOSITORY}";

# Generate a “canary” file to test restore later. A 12KB file * 24 * 365 * 10 ≈ 1 GB per decade.
# Only when backing up the entire home directory, because we need $HOME/etc/restickler/canary in the included set of backup files.
canary_file="$HOME/etc/restickler/canary/$(date '+%Y%m%d%H%M%S')";
if [[ $HOME == "$*" ]]; then
    find "$HOME/etc/restickler/canary" "/tmp/restickler/restore/$HOME/etc/restickler/canary" -type f -delete;
    head -c 11970 /dev/urandom > "$canary_file"
fi

#
# Go!
#

_info "Starting restickler $* to ${RESTIC_REPOSITORY}";

# shellcheck disable=SC2015
_restic_backup "$@" && _restic_test_restore "$@" || true;
_restic_forget || true;
_restic_prune || true;
_restic_check || true;

_info "Finished ($(_elapsed) elapsed)";
